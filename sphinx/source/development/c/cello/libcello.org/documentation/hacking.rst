=======================
Hacking C to its limits
=======================

概要
====

私はlibCello (当時はC+と名づけていた) を、Cにおける多様なオブジェクト指向の実装を楽しむための、面白おかしい実験として始めました。
幾分かの楽しい機能やクールなトリックを実現しましたが、時が経ち、行き詰まりがちになっていました。
アサーションが積み重なってしまったり、文法がひどいものになってしまったり、プログラマが手作業であまりに多くのことをやらなければならなかったり。
各々が、間違いを起こしやすい文字列に大きく依存したメッセージパッシングによるものでした。

ひとつ私が気づいたことは、根本的にCのバックエンドとPythonのようなスクリプト言語が共通点を持ち始めているということでした。

私はこうではないかと思いました。
異なる、または簡素化された推定を実装すれば、より良い文法と簡潔な意味論が実現し、そしてプログラマが手作業で行う工数を減らせるのではないかと。
スクリプト言語のような意味論、しかしながらCの性能とフロントエンドを持つものを創り出すことができるのではないかと。

libCelloは大域での変更と、たくさんのキュートなハックによって成り立っています。
大域での変更は、独創的すぎるものではありません。
しかし、キュートなハックと結びつくことで、とても使いやすいライブラリになりました。

この記事を短くすることで、肝心の詳細について幾分かを省略しています。
興味が湧いた方は、メールで応援したり、ソースコードを覗いてみたりして下さい！


型
--

言語の挙動を変えるためには、コンパイラまたはランタイムの変更を行う必要があります。
Cのような言語は、本質的に、ランタイムの仕組みを持っていません。
そういった言語は、何か別の言語のように見えるオブジェクトコードを生成します。
しかし、私たちは、自分たちの手でオブジェクトコードを追加できるのです。
私たちが追加する必要があるたった一つのもの、それは、私たちが欲しているほとんど全てのことを行う、強力な構造体なのです。

例えば、 ``new`` と ``delete`` を言語、あるいは私たちのシステム (ランタイム) に追加したいと望んだとしましょう。
私たちは割り当てるメモリのサイズを知らなければなりませんでした。
これこそ、 *型* の情報としても知られる *メタデータ* なのです。
私たちは、プログラムが動作する間、これをどこかへ保管しなければなりません。
それは分離されたテーブルでも可能かもしれませんが、私たちが操作したいと望んでいるオブジェクトそのものに紐付けると便利なことが多いです。

例を示します。構造体の先頭に *型* 又は *メタデータ* へのポインタを格納した *リッチな* オブジェクトを作ることができます。

.. code-block:: c

  typedef struct {
    type_t* meta_data;
    int other_data;
  } some_struct;

これらのオブジェクトを操作したいと望んだ場合、私たちはメタデータへのポインタを追いかけ、必要な情報を抽出するという手があります。
このエントリが常に構造体の先頭のエントリである場合、私たちが出会う構造体がいかなるものであっても、メタデータへのポインタを見つけるための場所を、私たちは常に把握することができます。
これはシンプルな仕組みです。しかし、不運なことに、これによって、私たちは最初から思い込みをしてしまうのです。それは少なからず避けることができません。

全ての *リッチな* オブジェクトは、このエントリから始まらなければなりません。しかし、プログラマはこの追加作業を慎重に行う必要があります。 **プログラマは忘れることがあるのです。**

私たちが知っているように、Cには隠れたコストというものが存在しません。これは有名なことです。
あなたは、あなたが使用するもののためだけに、コストを支払えばよいのです。
これが、先ほど言及した不可避の理由です。
Cを使う以上、あなたが前述のエントリをあるプログラマの構造体へ無意識のうちに挿し込む手段はありません。
そのようにできるというのであれば、それは正直なことではないでしょう。そしてCは嘘つきを嫌います。

では、型情報を、構造体のメモリの場所から生成したインデックスを持つ、プログラムとは分離したテーブルへ保持するというのはどうでしょう？
これは実に上手く機能します。しかし、これの意味するところは、いかなる構造体であっても、それを生成する際には、私たちが定義した関数 (これにより、型情報をテーブルへと追加する) を経由しなければならないということでもあるのです。
多くの場合において、これは良い方法です。しかし、この関数の外部から与えられる有効なデータを保持しておくことが、より便利であることもあります。例えば、それはスタックの上部に生成します ( *ドル記号* の項目を見て下さい)。

ともかく、このコストを受け入れるのであれば、私たちは外の世界から見たら魔術のように見えるたくさんの新しい振る舞いを言語に追加することになるでしょう。
次のステージでは、 *メタデータ* オブジェクトを設計します！


メタデータ
----------


ジェネリック関数
----------------


型クラス
--------


これですべて？
--------------


トリック
========


ドル記号
--------


Foreach
-------


With
----


Lambda
------


例外
----


True/False
----------


